<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>PokéSnake: Snivy in the Grass</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,200..800&display=swap" rel="stylesheet">

  <style>
    :root{
      --green-1:#31902b;
      --green-2:#165412;
      --green-3:#1f7319;

      
      --canvas: 900px;
      --hud: 230px;
      --gap: 18px;
      --gameW: calc(var(--canvas) + var(--hud) + var(--gap));
    }

    body{
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      font-family: "Bricolage Grotesque", sans-serif;
      font-optical-sizing: auto;
      font-variation-settings: "wdth" 100;
      background: #ffffff;
    }

    .wrap{
      width: 100%;
      display: flex;
      justify-content: center;
    }

    .gameShell{
      
      width: var(--gameW);

      
      display: grid;
      grid-template-columns: var(--canvas) var(--hud);
      column-gap: var(--gap);
      grid-template-rows: auto auto;
      justify-content: center;
    }

    
    .header{
      grid-column: 1;
      text-align: center;
      margin-bottom: 14px;
    }

    
    .headerSpacer{
      grid-column: 2;
    }

    
    .title{
      color: var(--green-1);
      font-size: 42px;
      font-weight: 800;
      margin: 0 0 4px 0;
      letter-spacing: 0.2px;
    }

    .subhead{
      color: var(--green-2);
      font-size: 18px;
      font-weight: 500;
      margin: 0;
      opacity: 0.9;
    }

    .subhead a{
      color: var(--green-2);
      font-weight: 600;
      text-decoration: none;
      border-bottom: 2px solid rgba(22,84,18,0.18);
      transition: color 0.15s ease, border-color 0.15s ease;
    }
    .subhead a:hover{
      color: var(--green-1);
      border-bottom-color: var(--green-1);
    }

    
    canvas{
      grid-column: 1;
      border: 5px solid var(--green-2);
      image-rendering: auto;
      display: block;

      
      touch-action: none;
    }

    
    .hudRight{
      grid-column: 2;
      width: var(--hud);
      text-align: left;
      color: var(--green-3);
      font-weight: 700;
      user-select: none;
      padding-top: 8px;

      
      padding-left: 10px;
      box-sizing: border-box;
    }

    .stat{ margin-bottom: 14px; }

    .label{
      font-size: 18px;
      color: var(--green-2);
      font-weight: 800;
      letter-spacing: 0.2px;
      text-transform: uppercase;
      opacity: 0.95;
    }

    .valueRow{
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 34px;
      font-weight: 400;
      color: var(--green-3);
      line-height: 1;
    }

    #formIcon{
      height: 40px;
      width: 40px;
      image-rendering: auto;
      flex: 0 0 auto;
    }

    #formName{
      font-size: 34px;
      font-weight: 400;
      color: var(--green-3);
    }

    .divider{
      height: 2px;
      background: rgba(22,84,18,0.18);
      margin: 12px 0 14px 0;
      border-radius: 2px;
    }

    .controls{
      margin-top: 8px;
      font-size: 18px;
      color: var(--green-1);
      font-weight: 600;
      line-height: 1.3;
    }

    .controls kbd{
      font-family: inherit;
      font-weight: 800;
      padding: 2px 6px;
      border: 2px solid rgba(22,84,18,0.35);
      border-bottom-width: 3px;
      border-radius: 8px;
      background: rgba(49,144,43,0.08);
      color: var(--green-2);
      margin: 0 4px;
      display: inline-block;
      transform: translateY(-1px);
    }

    
    @media (max-width: 1100px){
      .gameShell{
        width: var(--canvas);
        grid-template-columns: 1fr;
        grid-template-rows: auto auto auto;
        justify-items: center;
      }

      .header{ grid-column: 1; }
      .headerSpacer{ display: none; }

      canvas{ grid-column: 1; }

      .hudRight{
        grid-column: 1;
        width: min(520px, 92vw);
        padding-top: 14px;
        padding-left: 0;
        text-align: center;
      }

      .valueRow{ justify-content: center; }
      .label{ text-align: center; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="gameShell">
      <div class="header">
        <div class="title">PokéSnake: Snivy in the Grass</div>
        <div class="subhead">
          made with love by
          <a href="https://x.com/flbreglass" target="_blank" rel="noopener">flbreglass</a>
          • Please adjust screen size to 75% for desktop!
        </div>
      </div>
      <div class="headerSpacer"></div>

      <canvas id="c" width="900" height="900"></canvas>

      <aside class="hudRight" aria-label="Game stats">
        <div class="stat">
          <div class="label">Score</div>
          <div class="valueRow"><span id="score">0</span></div>
        </div>

        <div class="stat">
          <div class="label">Form</div>
          <div class="valueRow" style="gap:12px;">
            <img id="formIcon" src="snivy.png" alt="Form icon">
            <span id="formName">Snivy</span>
          </div>
        </div>

        <div class="stat">
          <div class="label">Best</div>
          <div class="valueRow"><span id="best">0</span></div>
        </div>

        <div class="divider"></div>

        <div class="controls">
          <div><kbd>WASD</kbd> or Arrow Keys</div>
          <div style="margin-top:8px; opacity:0.9;">Mobile Controls: Swipe on the grid, Tap grid to start/restart</div>
          <br>
          <div><kbd>R</kbd> to start / restart</div>
        </div>
      </aside>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const formNameEl  = document.getElementById("formName");
  const bestEl  = document.getElementById("best");
  const formIconEl = document.getElementById("formIcon");

  const GRID = 20;
  const CELL = canvas.width / GRID;
  const TICK_MS = 130;

  const EVOLVE_AT = [17, 36];
  const CANDY_POINTS = 1;

  const BODY_COLOR = "#009933";
  const BODY_COLOR_ALT = "#11b848";

  const sprites = {
    snivy: new Image(),
    servine: new Image(),
    serperior: new Image(),
  };
  sprites.snivy.src = "snivy.png";
  sprites.servine.src = "servine.png";
  sprites.serperior.src = "serperior.png";

  const items = { rareCandy: new Image() };
  items.rareCandy.src = "rare-candy.png";

  const tiles = { grass: new Image() };
  tiles.grass.src = "grass.png";

  const grassTiles = [];

  let snake, dir, nextDir, food, score, alive, loopId;
  let started = false;

  let startAnimId = null;
  const startT0 = performance.now();

  let bestScore = Number(localStorage.getItem("pokesnakeBestScore") || 0);
  bestEl.textContent = bestScore;

  function randCell() { return Math.floor(Math.random() * GRID); }
  function samePos(a, b) { return a.x === b.x && a.y === b.y; }

  function getStage(scoreVal) {
    if (scoreVal >= EVOLVE_AT[1]) return 2;
    if (scoreVal >= EVOLVE_AT[0]) return 1;
    return 0;
  }

  function getFormName(stage) {
    return stage === 2 ? "Serperior" : stage === 1 ? "Servine" : "Snivy";
  }

  function getHeadSprite(stage) {
    if (stage === 2) return sprites.serperior;
    if (stage === 1) return sprites.servine;
    return sprites.snivy;
  }

  function updateFormUI() {
    const stage = getStage(score);
    formNameEl.textContent = getFormName(stage);
    formIconEl.src = getHeadSprite(stage).src;
  }

  function spawnFood() {
    let p;
    do { p = { x: randCell(), y: randCell() }; }
    while (snake.some(s => samePos(s, p)));
    return p;
  }

  function setDirection(x, y) {
    if (!started || !alive) return;
    if (x === -dir.x && y === -dir.y) return;
    nextDir = { x, y };
  }

  function reset(startTimer = true) {
    grassTiles.length = 0;
    for (let y = 0; y < GRID; y++) {
      grassTiles[y] = [];
      for (let x = 0; x < GRID; x++) grassTiles[y][x] = tiles.grass;
    }

    const cx = Math.floor(GRID / 2);
    const cy = Math.floor(GRID / 2);
    snake = [{ x: cx, y: cy }, { x: cx - 1, y: cy }, { x: cx - 2, y: cy }];

    dir = { x: 1, y: 0 };
    nextDir = { ...dir };

    score = 0;
    alive = true;

    food = spawnFood();

    scoreEl.textContent = score;
    updateFormUI();

    if (loopId) clearInterval(loopId);
    loopId = null;

    if (startTimer) loopId = setInterval(tick, TICK_MS);

    draw();
  }

  function tick() {
    if (!alive || !started) return;

    dir = { ...nextDir };

    const head = snake[0];
    const newHead = { x: head.x + dir.x, y: head.y + dir.y };

    if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID) return gameOver();
    if (snake.some(seg => samePos(seg, newHead))) return gameOver();

    snake.unshift(newHead);

    if (samePos(newHead, food)) {
      score += CANDY_POINTS;
      scoreEl.textContent = score;

      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem("pokesnakeBestScore", String(bestScore));
        bestEl.textContent = bestScore;
      }

      updateFormUI();
      food = spawnFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function gameOver() {
    alive = false;
    if (loopId) clearInterval(loopId);
    loopId = null;
    draw(true);
  }

  function startScreenLoop(t){
    if (started) return;
    draw(false, t);
    startAnimId = requestAnimationFrame(startScreenLoop);
  }

  function draw(showGameOver = false, t = performance.now()) {
    if (!started) {
      ctx.fillStyle = "#000";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";

      ctx.font = '50px "Bricolage Grotesque", sans-serif';
      const textY = canvas.height / 2 - 30;
      ctx.fillText("Press R to Play!", canvas.width / 2, textY);

      
      const snivy = sprites.snivy;
      const bob = Math.sin((t - startT0) / 450) * 10;
      const iconSize = 120;

      const ix = (canvas.width / 2) - (iconSize / 2);
      const iy = (canvas.height / 2) + 10 + bob;

      if (snivy.complete && snivy.naturalWidth) {
        ctx.drawImage(snivy, ix, iy, iconSize, iconSize);
      }

      return;
    }

    ctx.fillStyle = "#FFFFFF";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.globalAlpha = 0.70;
    if (tiles.grass.complete && tiles.grass.naturalWidth) {
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          ctx.drawImage(grassTiles[y][x], x * CELL, y * CELL, CELL, CELL);
        }
      }
    }
    ctx.restore();

    const fx = food.x * CELL;
    const fy = food.y * CELL;

    ctx.save();
    ctx.globalAlpha = 0.55;
    ctx.fillStyle = "#fff";
    ctx.fillRect(fx, fy, CELL, CELL);
    ctx.restore();

    if (items.rareCandy.complete && items.rareCandy.naturalWidth) {
      ctx.drawImage(items.rareCandy, fx, fy, CELL, CELL);
    } else {
      ctx.fillStyle = "#111";
      ctx.fillRect(fx, fy, CELL, CELL);
    }

    const headSprite = getHeadSprite(getStage(score));

    for (let i = 0; i < snake.length; i++) {
      const s = snake[i];
      const x = s.x * CELL;
      const y = s.y * CELL;

      ctx.save();
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = "#000";
      ctx.fillRect(x + 1, y + 1, CELL, CELL);
      ctx.restore();

      if (i === 0 && headSprite.complete && headSprite.naturalWidth) {
        ctx.drawImage(headSprite, x, y, CELL, CELL);
      } else {
        ctx.fillStyle = (i % 2 === 0) ? BODY_COLOR : BODY_COLOR_ALT;
        ctx.fillRect(x, y, CELL, CELL);
      }
    }

    if (showGameOver) {
      ctx.fillStyle = "rgba(0,0,0,0.6)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#fff";
      ctx.textAlign = "center";
      ctx.font = '50px "Bricolage Grotesque", sans-serif';
      ctx.fillText("TRY AGAIN", canvas.width / 2, canvas.height / 2 - 20);

      ctx.font = '30px "Bricolage Grotesque", sans-serif';
      ctx.fillText("Press R to Restart!", canvas.width / 2, canvas.height / 2 + 25);
    }
  }

  //desktop
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();

    if (k === "r") {
      if (!started) {
        started = true;
        if (startAnimId) cancelAnimationFrame(startAnimId);
      }
      reset(true);
      return;
    }

    if (k === "arrowup" || k === "w") setDirection(0, -1);
    if (k === "arrowdown" || k === "s") setDirection(0, 1);
    if (k === "arrowleft" || k === "a") setDirection(-1, 0);
    if (k === "arrowright" || k === "d") setDirection(1, 0);
  });

  //mobile
  
  canvas.addEventListener("pointerdown", () => {
    if (!started) {
      started = true;
      if (startAnimId) cancelAnimationFrame(startAnimId);
      reset(true);
    } else if (!alive) {
      reset(true);
    }
  });

  
  let pStartX = 0, pStartY = 0;
  let pTracking = false;
  const SWIPE_MIN = 28;

  canvas.addEventListener("pointerdown", (e) => {
    pTracking = true;
    pStartX = e.clientX;
    pStartY = e.clientY;
  });

  canvas.addEventListener("pointerup", (e) => {
    if (!pTracking) return;
    pTracking = false;

    const dx = e.clientX - pStartX;
    const dy = e.clientY - pStartY;

    if (Math.abs(dx) < SWIPE_MIN && Math.abs(dy) < SWIPE_MIN) return;

    
    if (!started) {
      started = true;
      if (startAnimId) cancelAnimationFrame(startAnimId);
      reset(true);
      return;
    }

    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 0) setDirection(1, 0);
      else setDirection(-1, 0);
    } else {
      if (dy > 0) setDirection(0, 1);
      else setDirection(0, -1);
    }
  });

  
  canvas.addEventListener("pointercancel", () => { pTracking = false; });

  
  reset(false);
  startAnimId = requestAnimationFrame(startScreenLoop);
})();
</script>
</body>
</html>
